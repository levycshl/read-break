# parsers/template_copy_extract.yaml
# Purpose: Identify well-formed templates and extract:
#   - R1: template_tag (V12, no T) and DNA insert
#   - R2: copy_tag (B15, no A) and DNA insert
# Robustness: allows the explicit variable-length prefixes at the 5' ends
# Conversion-aware matching: R1 uses hammingTC (T→C-blind), R2 uses hammingAG (A→G-blind)
#
## COULD BE IMPROVED BY LOOKING FOR READTHROUGH

params:
  # ---- Constants from your design ----
  # Variable-length prefixes at 5' ends:
  # R1: "" | A | TG | GAC  (lengths 0,1,2,3) then N15, then const1
  # R2: "" | G | CA | TGT  (lengths 0,1,2,3) then const0
  r1_prefix_max_wobble: 3         # accounts for "", A, TG, GAC
  r2_prefix_max_wobble: 3         # accounts for "", G, CA, TGT

  r1_n_len: 15                    # R1 N(15) after prefix

  # R1 constants & lengths
  r1_const1: "AGCCAGGAGACAGAGC"   # immediately after prefix+N15
  r1_const1_len: 16
  r1_tag_len: 12                  # V(12), no T
  r1_const2: "GTATCAACGCAGAGTCATG"
  r1_const2_len: 19

  # R2 constants & lengths
  r2_const0: "GTTGCTTGGTGCTGGT"   # immediately after prefix
  r2_const0_len: 16
  r2_tag_len: 15                  # B(15), no A
  r2_const1: "GCCACTGCACTCCAGCCTGGGCGACAGAGC"
  r2_const1_len: 30

  # Extract-to-end padding for 'extract' (overshoot is safe in Python slicing)
  big_len: 1000000

pipeline:

  # ---------- READ 1 ----------
  # Find R1 const1 allowing for prefix (0..3 bp) + N(15) and T→C asymmetry.
  - id: r1_match_const1
    read: 1
    op: match
    ref: "{{ params.r1_const1 }}"
    hamming_fn: "hammingTC"             # T→C-blind
    max_mismatch: 2
    base_offset: "{{ params.r1_n_len }}" # start search after N15
    max_wobble: "{{ params.r1_prefix_max_wobble }}"
    store_pos_as: r1_wobble_pos
    must_pass: true

  - id: r1_verify_const1
    read: 1
    op: hamming_test
    ref: "{{ params.r1_const1 }}"
    hamming_fn: "hammingTC"
    max_mismatch: 2
    start: "{{ params.r1_n_len + r1_wobble_pos }}"
    length: "{{ params.r1_const1_len }}"
    store_result_as: r1_const1_ok
    must_pass: true

  - id: r1_compute_tag_start
    read: 1
    op: compute
    expression: "{{ r1_wobble_pos + params.r1_n_len + params.r1_const1_len }}"
    store_as: r1_tag_start

  - id: r1_match_const2
    read: 1
    op: hamming_test
    ref: "{{ params.r1_const2 }}"
    hamming_fn: "hammingTC"
    max_mismatch: 2
    start: "{{ r1_tag_start + params.r1_tag_len }}"
    length: "{{ params.r1_const2_len }}"
    store_result_as: r1_const2_check
    must_pass: true

  # Extract the template tag immediately after const1 (V12, no T)
  - id: r1_extract_template_tag
    read: 1
    op: extract
    start: "{{ r1_tag_start }}"
    length: "{{ params.r1_tag_len }}"
    store_seq_as: template_tag


  # Extract the dna insert immediately after const1 (V12, no T)
  - id: r1_extract_dna_insert
    read: 1
    op: compute
    expression: "{{ r1_tag_start + params.r1_tag_len + params.r1_const2_len }}"
    store_as: start_r1
    
      # ---------- READ 2 ----------
  # Find R2 const0 allowing for prefix (0..3 bp) and A→G asymmetry.
  - id: r2_match_const0
    read: 2
    op: match
    ref: "{{ params.r2_const0 }}"
    hamming_fn: "hammingAG"       # A→G-blind
    max_mismatch: 2
    base_offset: 0
    max_wobble: "{{ params.r2_prefix_max_wobble }}"
    store_pos_as: r2_wobble_pos
    must_pass: true

  - id: r2_verify_const0
    read: 2
    op: hamming_test
    ref: "{{ params.r2_const0 }}"
    hamming_fn: "hammingAG"
    max_mismatch: 2
    start: "{{ r2_wobble_pos }}"
    length: "{{ params.r2_const0_len }}"
    store_result_as: r2_const0_ok
    must_pass: true

  - id: r2_compute_copy_tag_start
    read: 2
    op: compute
    expression: "{{ r2_wobble_pos + params.r2_const0_len }}"
    store_as: r2_copy_tag_start

  # Confirm downstream const1 is exactly after the copy tag
  - id: r2_match_const1
    read: 2
    op: hamming_test
    ref: "{{ params.r2_const1 }}"
    hamming_fn: "hammingAG"
    max_mismatch: 2
    start: "{{ r2_copy_tag_start + params.r2_tag_len }}"
    length: "{{ params.r2_const1_len }}"
    store_result_as: r2_const1_check
    must_pass: true

  # Extract the copy tag (B15, no A)
  - id: r2_extract_copy_tag
    read: 2
    op: extract
    start: "{{ r2_copy_tag_start }}"
    length: "{{ params.r2_tag_len }}"
    store_seq_as: copy_tag

  # (Optional) enforce no 'A' constraint on copy_tag; enable if desired
  # - id: r2_copy_tag_no_A
  #   op: test
  #   expression: "{{ 'A' not in copy_tag }}"
  #   store_result_as: copy_tag_not_contains_A
  #   must_pass: true

  # Compute start of R2 DNA insert (just after const1)
  - id: r2_extract_dna_insert
    read: 2
    op: compute
    expression: "{{ r2_copy_tag_start + params.r2_tag_len + params.r2_const1_len }}"
    store_as: start_r2

  - id: get_read_tag
    op: compute
    expression: "'{{ template_tag ~ '_' ~ copy_tag }}'"
    store_as: read_tag

